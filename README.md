# Proyecto de ETL y Data Warehouse para GestiÃ³n Comercial ðŸ“Š

Este proyecto implementa un proceso completo de **ETL (ExtracciÃ³n, TransformaciÃ³n y Carga)** para centralizar y estructurar los datos comerciales de tres empresas distintas. El objetivo es crear un **Data Warehouse** robusto en PostgreSQL que sirva como una Ãºnica fuente de verdad para el anÃ¡lisis de negocio, la generaciÃ³n de informes y el cÃ¡lculo de comisiones.

---
## Arquitectura y MetodologÃ­as Clave ðŸ§ 

La soluciÃ³n estÃ¡ diseÃ±ada siguiendo las mejores prÃ¡cticas de la ingenierÃ­a de datos:

1.  **ExtracciÃ³n:** Scripts de Python se conectan a una API de TNS para extraer datos crudos de productos, clientes y vendedores.
2.  **TransformaciÃ³n:** Los datos extraÃ­dos pasan por una capa de limpieza, estandarizaciÃ³n y enriquecimiento. Se aplican reglas de negocio para corregir inconsistencias.
3.  **Carga:** Los datos limpios se cargan en una base de datos PostgreSQL, diseÃ±ada con un **Esquema en Estrella**.
4.  **GestiÃ³n y AuditorÃ­a:** Un conjunto de scripts de apoyo permite la gestiÃ³n manual de clasificaciones de negocio y genera reportes para mantener la calidad de los datos.

###MetodologÃ­as Clave de Modelado de Datos ðŸ’¡

La soluciÃ³n se basa en principios sÃ³lidos de ingenierÃ­a de datos para garantizar la integridad, eficiencia y escalabilidad del sistema.

### Esquema en Estrella (Star Schema)
Es el pilar de nuestro diseÃ±o. Consiste en separar los datos en dos tipos de tablas:

* **Tablas de Hechos (Fact Tables):** Almacenan las mediciones numÃ©ricas de los procesos de negocio. Son el centro de nuestro anÃ¡lisis y suelen ser las tablas mÃ¡s grandes.
    * **`hechos_ventas`:** Es la tabla principal del modelo. Cada fila representa una lÃ­nea de detalle de una factura (un producto vendido a un cliente en un momento dado). Contiene mÃ©tricas como `cantidad`, `valor_total`, `costo_total`, etc., y se conecta con todas las dimensiones (productos, clientes, vendedores, tiempo, bodegas).
    * **`hechos_inventario`:** Guarda "fotos" periÃ³dicas (snapshots) del inventario, idealmente a fin de mes. Su propÃ³sito es permitir el anÃ¡lisis de la evoluciÃ³n y tendencias de las existencias a lo largo del tiempo.
    * **`inventario_actual`:** Es una tabla de hechos especial que no guarda historial, sino que refleja el estado *actual* del inventario. Se actualiza cada dÃ­a para consultas operativas rÃ¡pidas sobre las existencias disponibles.

* **Tablas de DimensiÃ³n (Dimension Tables):** Contienen el contexto descriptivo ("quiÃ©n, quÃ©, cuÃ¡ndo, dÃ³nde") para los hechos. Son las tablas que usamos para filtrar y agrupar los datos en los reportes. Ejemplos: `dim_productos`, `maestro_clientes`, `dim_tiempo`, `dim_bodegas`.

### Dimensiones de Lenta VariaciÃ³n (SCD)
Los atributos de negocio cambian con el tiempo. Para manejar estos cambios sin perder el historial, implementamos la metodologÃ­a **SCD Tipo 2**. En lugar de sobrescribir un registro, "cerramos" el antiguo con una `fecha_fin_validez` y creamos uno nuevo con una nueva `fecha_inicio_validez`. Esto nos permite reconstruir la historia con total precisiÃ³n, como en el caso de la tabla `dim_roles_comerciales_historia`.

### Dimensiones Conformes
Son dimensiones que se comparten entre mÃºltiples tablas de hechos. En nuestro caso, `Dim_Bodegas` es una dimensiÃ³n conforme, ya que se utiliza tanto en `Hechos_Inventario` como en `Hechos_Ventas`. Esto asegura consistencia y permite realizar anÃ¡lisis cruzados entre diferentes procesos de negocio.

### Procesos Idempotentes
Nuestros scripts de carga y sincronizaciÃ³n estÃ¡n diseÃ±ados para ser **idempotentes**. Esto significa que se pueden ejecutar mÃºltiples veces con los mismos datos de entrada y el resultado final en la base de datos serÃ¡ el mismo, sin generar duplicados ni errores. Esto se logra mediante el uso de comandos `INSERT ... ON CONFLICT DO UPDATE` (UPSERT) o estrategias de `TRUNCATE` y recarga.

Este proyecto utiliza varios conceptos fundamentales para asegurar que la informaciÃ³n sea Ã­ntegra y eficiente.

* **Llaves Sustitutas vs. de Negocio:** Usamos IDs numÃ©ricos internos (`id_producto`) para la eficiencia de la base de datos (Llave Sustituta) y mantenemos los cÃ³digos del mundo real (`codigo_erp`) para el anÃ¡lisis y la lÃ³gica de negocio (Llave de Negocio).

---
## Estructura del Repositorio ðŸ“‚

```
proyectos-gestion-comercial/
â”‚
â”œâ”€â”€ .env                  # (Local) Archivo para guardar credenciales de forma segura.
â”œâ”€â”€ config.py             # MÃ³dulo de configuraciÃ³n central (rutas, URLs, credenciales).
â”œâ”€â”€ db_utils.py           # Funciones de utilidad para la conexiÃ³n a la base de datos.
â”œâ”€â”€ requirements.txt      # Dependencias de Python para el proyecto.
â”œâ”€â”€ README.md
â”‚
â”œâ”€â”€ sql/
â”‚   â””â”€â”€ gestion_comercial_schema.sql # Script SQL para crear toda la estructura de la base de datos.
â”‚
â”œâ”€â”€ datos_entrada/        # Archivos CSV para la carga y gestiÃ³n manual.
â”‚
â”œâ”€â”€ informes_generados/   # Carpeta donde los scripts de auditorÃ­a guardan los reportes.
â”‚
â”œâ”€â”€ 00_ETL_TNS/           # Scripts que se conectan a la API para la carga diaria de datos crudos.
â”‚   â”œâ”€â”€ cargar_productos_api.py                 # Sincroniza la tabla `dim_productos`.
â”‚   â”œâ”€â”€ cargar_clientes_api.py                  # Sincroniza la tabla `dim_clientes_empresa`.
â”‚   â”œâ”€â”€ cargar_vendedores_api_crudo.py          # Guarda un snapshot diario de los vendedores de la API.
â”‚   â”œâ”€â”€ cargar_inventario_api.py                # Sincroniza la tabla `inventario_actual`.
â”‚   â””â”€â”€ cargar_ventas_api.py                    # Sincroniza y actualiza la tabla de hechos_ventas.
â”‚
â””â”€â”€ 01_MODELO_DATOS_Y_AUXILIARES/               # Scripts de apoyo, auditorÃ­a y sincronizaciÃ³n.
    â”œâ”€â”€ poblar_dimensiones_catalogo.py          # Para la carga inicial de catÃ¡logos (lÃ­neas, marcas, etc.).
    â”‚
    â”œâ”€â”€ poblar_dim_tiempo.py                    # Script que pobla la tabla de dimensiÃ³n de tiempo.
    â”‚
    â”œâ”€â”€ auditoria_gestion_productos.py          # Genera un reporte de productos activos sin clasificar.
    â”œâ”€â”€ sincronizar_gestion_productos.py        # Sincroniza el CSV de gestiÃ³n de productos con la BD.
    â”‚
    â”œâ”€â”€ auditoria_gestion_clientes.py           # Genera un reporte de clientes activos sin gestionar.
    â”œâ”€â”€ sincronizar_maestro_clientes.py         # Sincroniza el CSV maestro de clientes con la BD.
    â”œâ”€â”€ sincronizar_clasificacion_clientes.py   # Sincroniza las clasificaciones histÃ³ricas de clientes.
    â”‚
    â”œâ”€â”€ auditoria_gestion_vendedores.py         # Genera un reporte de vendedores activos sin gestionar.
    â”œâ”€â”€ sincronizar_maestro_personas.py         # Sincroniza el CSV maestro de personas con la BD.
    â”œâ”€â”€ sincronizar_roles_vendedores.py         # Sincroniza el CSV roles comerciales histÃ³rico con la BD.
    â”‚
    â””â”€â”€ generar_snapshot_inventario.py          # Consume la informaciÃ³n del inventario actual para agregar al histÃ³rico de inventarios.
```

---
## CÃ³mo Empezar (GuÃ­a de InstalaciÃ³n) ðŸš€

1.  **Clonar el Repositorio:** `git clone https://github.com/EdinsonHernandez92/proyectos_gestion_comercial.git`
2.  **Entorno Virtual:** `python -m venv venv` y actÃ­valo.
3.  **Archivo `.env`:** Crea el archivo `.env` en la raÃ­z y rellÃ©nalo con las credenciales de la base de datos y de la API.
4.  **Instalar Dependencias:** `pip install -r requirements.txt`
5.  **Crear Base de Datos:** Crea una base de datos en PostgreSQL llamada `gestion_comercial` y ejecuta el script `sql/gestion_comercial_schema.sql` para crear todas las tablas.

---
## Flujo de Trabajo de los Scripts ETL

El proyecto se divide en procesos automÃ¡ticos (para datos de la API) y procesos manuales (para tus datos de gestiÃ³n).

### 1. Proceso Diario (AutomÃ¡tico)
Estos scripts deben ejecutarse diariamente para mantener los datos maestros sincronizados con la API.

* **`cargar_productos_api.py`:**
    * **MisiÃ³n:** Se conecta a la API, extrae la lista completa de productos para las tres empresas y la carga en la tabla `dim_productos` usando una lÃ³gica de **UPSERT** (inserta si es nuevo, actualiza si existe).
    * **Reporte:** Antes de cargar, compara los datos de la API con los existentes en la base de datos y genera un reporte en `informes_generados/` con los productos nuevos o modificados detectados en la API.
* **`cargar_clientes_api.py`:**
    * **MisiÃ³n:** Sincroniza la tabla `dim_clientes_empresa` con la API.
    * **Reporte:** Genera un CSV en `informes_generados/` con los clientes nuevos o modificados detectados en la API.
* **`cargar_vendedores_api_crudo.py`**
    * **AcciÃ³n:** Extrae de la API solo los terceros que son vendedores activos (cÃ³digo empieza con 'V' y no estÃ¡n inactivos) y los guarda en la tabla `api_vendedores_crudo`. Esta tabla se vacÃ­a y se recarga cada dÃ­a para tener un "espejo" de la realidad de la API.
* **`cargar_inventario_api.py`:** Actualiza la tabla `Inventario_Actual` con las existencias del dÃ­a.
* **`cargar_ventas_api.py`:** Carga las transacciones de ventas del dÃ­a en la tabla `hechos_ventas`.

### 2. Proceso de GestiÃ³n (Manual) - ClasificaciÃ³n y Calidad
Este es el flujo de trabajo para clasificar y mantener la calidad de los datos maestros.

#### Flujo para Productos
1.  **AuditorÃ­a:** Ejecutas `auditoria_gestion_productos.py`. El script busca productos con ventas o inventario reciente que aÃºn no estÃ¡n en tu tabla `gestion_productos_aux` y te genera el CSV `productos_pendientes_por_clasificar.csv`.
2.  **AcciÃ³n Manual:** Editas tu archivo maestro `gestion_productos_aux.csv`, aÃ±adiendo los nuevos productos y rellenando sus clasificaciones.
3.  **SincronizaciÃ³n:** Ejecutas `sincronizar_gestion_productos.py`. El script lee tu CSV actualizado, busca los IDs correspondientes en `dim_productos` y sincroniza (UPSERT) la tabla `gestion_productos_aux`.

#### Flujo para Clientes
1.  **AuditorÃ­a:** Ejecutas `auditoria_gestion_clientes.py`. El script busca clientes activos en `dim_clientes_empresa` que aÃºn no tienen un `id_maestro_cliente_fk` asignado y te genera el CSV `clientes_pendientes_por_clasificar.csv`.
2.  **AcciÃ³n Manual:** Editas tus dos archivos maestros:
    * `maestro_clientes.csv`: AÃ±ades los nuevos clientes, asignÃ¡ndoles un `cod_cliente_maestro` Ãºnico.
    * `dim_clientes_clasificacion_historia.csv`: AÃ±ades las filas de clasificaciÃ³n para estos nuevos clientes.
3.  **SincronizaciÃ³n:** Ejecutas en orden:
    * `sincronizar_maestro_clientes.py`: Para actualizar la lista de clientes maestros.
    * `sincronizar_clasificacion_clientes.py`: Para actualizar sus clasificaciones.

#### Flujo para Vendedores
1.  **AuditorÃ­a:** (Pendiente de creaciÃ³n) `auditoria_gestion_vendedores.py` compararÃ¡ `api_vendedores_crudo` con tus tablas de gestiÃ³n para reportar inconsistencias.
2.  **AcciÃ³n Manual:** Editas tus archivos maestros:
    * `maestro_personas.csv`: Para aÃ±adir nuevos empleados (vendedores, supervisores).
    * `dim_roles_comerciales_historia.csv`: Para asignar roles, supervisores y periodos de validez.
3.  **SincronizaciÃ³n:** Ejecutas en orden:
    * `sincronizar_maestro_personas.py`: Para actualizar la lista de personal.
    * `sincronizar_roles_vendedores.py`: Para actualizar el historial de roles.

#### Flujo para Inventario

Este flujo mantiene actualizadas las tablas de existencias.

1.  **`cargar_inventario_api.py` (Diario/Programado):**
    * **MisiÃ³n:** Se conecta al endpoint de la API que contiene los productos, "aplana" la informaciÃ³n anidada de las bodegas y aplica los filtros de negocio (bodegas permitidas, lista de precios).
    * **AcciÃ³n:** Actualiza la tabla `Inventario_Actual` con las existencias mÃ¡s recientes para cada producto en cada bodega, usando una lÃ³gica de **UPSERT**.

2.  **`generar_snapshot_inventario.py` (PeriÃ³dico, ej. mensual):**
    * **MisiÃ³n:** Crea un registro histÃ³rico del inventario.
    * **AcciÃ³n:** Toma una "foto" de todo el contenido de la tabla `Inventario_Actual` y la inserta en la tabla `Hechos_Inventario` con la fecha del dÃ­a en que se ejecuta. Esto permite el anÃ¡lisis de tendencias de inventario a lo largo del tiempo.